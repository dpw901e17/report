\chapter{Introduction}\label{ch:introduction} 
Since their initial burst of arcade popularity arcades in the 1970’s and 80’s, video games have been moved into the homes of consumers and have become a mainstream avenue for entertainment.
 
While these applications vary greatly, they are always structured around a game loop as shown in \cref{fig:gameLoop}. 
Processing this loop, the game takes input from the player, such as button presses. 
This input is used when updating the game world. 
The updated world is then rendered visually on a screen. 
For instance, if the player pushes the forward key, the position of their character will be updated, and the rendered image will show them to have moved forward. 

\fig{figures/GameLoop.pdf}{The common video game loop.}{gameLoop}{1}

The frequency at which the application passes through this loop is measured in \gls{FPS}.
Games are commonly designed to be played at around 60 \gls{FPS}, which is the refresh rate of most computer monitors and TVs.
To keep up, the game only has around 16 miliseconds to process each loop.
If it takes longer, there is a risk of negatively impacting the game playing experience, because of lagging gameplay and visuals.
 
Programming causal games like Tetris, 60 \gls{FPS} is not a difficult goal to reach.
Yet, in the case of modern AAA-games the implementation of even the simplest subsystem becomes non-trivial.
Entering the loop, the game may not only concern itself with the input from the player.
It may also take input from an \gls{AI} system impacting the game world, such as controlling \glspl{NPC}. 
Updating the game world involves processing many objects using a complex physics engine. 
After an update a highly detailed model of each object must be rendered to screen and shaded using a lighting engine.  
 
Each of these sub-processes are complex, and are all worthy of further investigation.
Yet, to limit the scope of this report, we choose to focus only on the graphical rendering of the game world.
This is because we have taken an interest in the tools used for graphics programming, both concerning their performance and programmability.
To further narrow our scope, we focus only on graphics programming regarding video games.
The topic of graphics programming is much broader than what is presented in this text, and includes for instance the rendering \gls{CGI}for modern movies. 
The following section will give a breif overview of computer graphics.

\section{A Breif Overview Of Computer Graphics}
In the early days of consumer electronics, computer visuals were mainly displayed as text.
Yet, with the combined rise of microcomputers and \glspl{GUI} in the 80's, graphics and visuals became a hot topic for both developers and consumers.\todo{Some sources perhaps needed on the historical claims in general.} 
In the 1990s, highly parallel graphics hardware in the form of \glspl{GPU} were introduced to render 3D models in real time.
The first \gls{GPU} was created by Nvidia, its main purpose was to render 3D graphics better and faster than before. \cite{NvidiaFirstGPU} \todo{måske nævne hvilken GPU det er? Kunne diskutere om den nye GPU var så forskellig fra grafikkort fra tidligere}
This piece of hardware has become a stable in modern consumer computers, either as an individual component or integrated the CPU.

%Computers and applications are no longer the niche market it was in its early days, and from that comes a need for intuitive interfaces for users. 
%Around the 1970s the first computers with \glspl{GUI} started to appear to improve the user experience.
To ease development of graphical applications, graphics \glspl{API} were created. 
These allow developers to work with the GPU at a more abstract level, through an interface.
%But to develop these \glspl{GUI}, developers use a lot of time working with the graphics \glspl{API}.
Developers have used these \glspl{API} to create impressive applications, such as modern video games, which render graphics in real time at 60 frames per second (at times more than that), as well as the graphically demanding \glspl{GUI} of modern operating systems.

%As hardware improves, so must the \gls{API} to better use the improvements.
%Another function of the \gls{API} is to make it easier for the developers to use the hardware so improvement in that area is also interesting for the \gls{API} developers.
Graphics \glspl{API} have to evolve alongside modern CPU and GPU architectures, to take advantage of new features. 
Yet, academic research into the evaluation of \glspl{API} and how to improve them is limited though the litterature is growing.
Even if the newer \glspl{API} supports operations that improve performance, if the feature is too difficult to use most developers will ignore it.

Video games have always had high demands on hardware, even before the introduction of \glspl{GPU}.
Because of the constant demand from developers and consumers to render more demanding graphics in real time, \gls{GPU} manufacturers have continually made the \gls{GPU} throughput higher with each new \gls{GPU} release

With the release of the most recent graphics \glspl{API}; Vulkan and Direct3D 12, there has been a push towards a more low-level API design, which gives the programmer more control over the graphics pipeline.
Much of the functionality that was previously handled by the driver, should now be handled by application developers. 
This has some advantages, which will be discussed in detail in the following chapter \cref{sec:graphics_apis}.
Yet, the argument that lower levels of abstraction results in better \glspl{API} would suggest that writing in binary or assembly would provide the best \glspl{API}.\todo{Synes at der skal gås mere i detalje med den her linje, eller vi skal vente med den diskution til senere}

In this report, we are instested in how the newer \glspl{API} lower their abstraction-level, and what advantages and disadvantages this approach has both on performance and programability.
The aim is to generate insight into the graphics \glspl{API}; Direct3D 12 and Vulkan, and to generate tools for future developers that can be used to evaluate and improve their \glspl{API}.\todo{Hvad er det for nogle tools vi taler om her?}

Direct3D 12 and Vulkan are chosen, because they are released close to eachother (2015 and 2016 respecively), and have some overlapping ideas on how to improve graphics \glspl{API}, such as better multithread support on the CPU.
The predesessors to these \glspl{API} (Direct3D 11 and OpenGL 4.5) are some of the most broadly used graphics \glspl{API} for realtime rendering, and we suspect that Direct3D 12 and Vulkan will have similar success in the comming years.

In the following section we will define the problem statement of the report in detail.
The reply to the questions presented will be the goal of the rest of the rest of the work presented here.

\input{mainmatter/introduction/problem_statement/index.tex}
